#include <iostream>
#include <thread>
#include <atomic>
#include <chrono>
#include <cstdlib>
#include <ctime>
#include <mutex>
#include <condition_variable>

using namespace std;

atomic<bool> interruptPending(false);
atomic<bool> masked(false);
atomic<bool> running(true);

mutex mtx;
condition_variable cv;

// Simulate keyboard device generating interrupts
void keyboardDevice() {
    srand(time(nullptr));
    while (running) {
        // Wait for a random interval (simulate key press)
        int delay = 1000 + rand() % 2000; // 1–3 seconds
        this_thread::sleep_for(chrono::milliseconds(delay));

        if (!running) break;

        // Raise interrupt
        {
            lock_guard<mutex> lock(mtx);
            interruptPending = true;
            cout << "\n[Device] Keyboard interrupt signal raised!" << endl;
        }
        cv.notify_one(); // wake controller
    }
}

// Interrupt Service Routine (ISR)
void handleKeyboardInterrupt() {
    cout << "Keyboard Interrupt Triggered → Handling ISR";
    this_thread::sleep_for(chrono::milliseconds(500)); // simulate ISR delay
    cout << " → Completed" << endl;
}

// Interrupt controller logic
void interruptController() {
    while (running) {
        unique_lock<mutex> lock(mtx);
        cv.wait(lock, [] { return interruptPending || !running; });

        if (!running) break;

        if (masked) {
            cout << "Keyboard Interrupt Ignored (Masked)" << endl;
            interruptPending = false;
        } else if (interruptPending) {
            interruptPending = false;
            lock.unlock(); // unlock while handling ISR
            handleKeyboardInterrupt();
        }
    }
}

// Main program for controlling simulation
int main() {
    cout << "=== Keyboard Interrupt Simulation (C++) ===" << endl;
    cout << "Commands: mask, unmask, exit" << endl;

    thread deviceThread(keyboardDevice);
    thread controllerThread(interruptController);

    string command;
    while (true) {
        cout << "\n> ";
        cin >> command;

        if (command == "mask") {
            masked = true;
            cout << "Keyboard interrupt masked." << endl;
        } 
        else if (command == "unmask") {
            masked = false;
            cout << "Keyboard interrupt unmasked." << endl;
        } 
        else if (command == "exit") {
            running = false;
            cv.notify_all();
            break;
        } 
        else {
            cout << "Unknown command. Use: mask, unmask, exit" << endl;
        }
    }

    deviceThread.join();
    controllerThread.join();

    cout << "\nSimulation stopped." << endl;
    return 0;
}
